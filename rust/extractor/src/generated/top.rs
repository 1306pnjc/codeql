// generated by codegen

use crate::trap::{TrapId, TrapEntry};
use codeql_extractor::trap;

#[derive(Debug)]
pub struct DbFile {
    pub id: TrapId,
    pub name: String,
}

impl TrapEntry for DbFile {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("db_files", vec![trap::Arg::Label(id)]);
        out.add_tuple("files", vec![trap::Arg::Label(id), self.name.into()]);
    }
}

#[derive(Debug)]
pub struct DbLocation {
    pub id: TrapId,
    pub file: trap::Label,
    pub start_line: usize,
    pub start_column: usize,
    pub end_line: usize,
    pub end_column: usize,
}

impl TrapEntry for DbLocation {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("db_locations", vec![trap::Arg::Label(id)]);
        out.add_tuple("locations", vec![trap::Arg::Label(id), self.file.into(), self.start_line.into(), self.start_column.into(), self.end_line.into(), self.end_column.into()]);
    }
}

#[derive(Debug)]
pub struct Function {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub name: String,
}

impl TrapEntry for Function {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("functions", vec![trap::Arg::Label(id), self.name.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct Module {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub declarations: Vec<trap::Label>,
}

impl TrapEntry for Module {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("modules", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, &v) in self.declarations.iter().enumerate() {
            out.add_tuple("module_declarations", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
    }
}
