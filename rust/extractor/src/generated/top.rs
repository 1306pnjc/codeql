// generated by codegen

#![cfg_attr(any(), rustfmt::skip)]

use crate::trap;

#[derive(Debug)]
pub struct Element {
    pub id: trap::TrapId<Element>,
}

impl trap::TrapEntry for Element {
    fn class_name() -> &'static str { "Element" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("elements", vec![id.into()]);
    }
}

#[derive(Debug)]
pub struct Locatable {
    pub id: trap::TrapId<Locatable>,
}

impl trap::TrapEntry for Locatable {
    fn class_name() -> &'static str { "Locatable" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("locatables", vec![id.into()]);
    }
}

impl From<trap::Label<Locatable>> for trap::Label<Element> {
    fn from(value: trap::Label<Locatable>) -> Self {
        // SAFETY: this is safe because in the dbscheme Locatable is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct AstNode {
    pub id: trap::TrapId<AstNode>,
}

impl trap::TrapEntry for AstNode {
    fn class_name() -> &'static str { "AstNode" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("ast_nodes", vec![id.into()]);
    }
}

impl From<trap::Label<AstNode>> for trap::Label<Element> {
    fn from(value: trap::Label<AstNode>) -> Self {
        // SAFETY: this is safe because in the dbscheme AstNode is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AstNode>> for trap::Label<Locatable> {
    fn from(value: trap::Label<AstNode>) -> Self {
        // SAFETY: this is safe because in the dbscheme AstNode is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Declaration {
    pub id: trap::TrapId<Declaration>,
}

impl trap::TrapEntry for Declaration {
    fn class_name() -> &'static str { "Declaration" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("declarations", vec![id.into()]);
    }
}

impl From<trap::Label<Declaration>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Declaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme Declaration is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Declaration>> for trap::Label<Element> {
    fn from(value: trap::Label<Declaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme Declaration is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Declaration>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Declaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme Declaration is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Expr {
    pub id: trap::TrapId<Expr>,
}

impl trap::TrapEntry for Expr {
    fn class_name() -> &'static str { "Expr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("exprs", vec![id.into()]);
    }
}

impl From<trap::Label<Expr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Expr>) -> Self {
        // SAFETY: this is safe because in the dbscheme Expr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Expr>> for trap::Label<Element> {
    fn from(value: trap::Label<Expr>) -> Self {
        // SAFETY: this is safe because in the dbscheme Expr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Expr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Expr>) -> Self {
        // SAFETY: this is safe because in the dbscheme Expr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Label {
    pub id: trap::TrapId<Label>,
    pub name: String,
}

impl trap::TrapEntry for Label {
    fn class_name() -> &'static str { "Label" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("labels", vec![id.into(), self.name.into()]);
    }
}

impl From<trap::Label<Label>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Label>) -> Self {
        // SAFETY: this is safe because in the dbscheme Label is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Label>> for trap::Label<Element> {
    fn from(value: trap::Label<Label>) -> Self {
        // SAFETY: this is safe because in the dbscheme Label is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Label>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Label>) -> Self {
        // SAFETY: this is safe because in the dbscheme Label is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MatchArm {
    pub id: trap::TrapId<MatchArm>,
    pub pat: trap::Label<Pat>,
    pub guard: Option<trap::Label<Expr>>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for MatchArm {
    fn class_name() -> &'static str { "MatchArm" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("match_arms", vec![id.into(), self.pat.into(), self.expr.into()]);
        if let Some(v) = self.guard {
            out.add_tuple("match_arm_guards", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<MatchArm>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MatchArm>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchArm is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchArm>> for trap::Label<Element> {
    fn from(value: trap::Label<MatchArm>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchArm is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchArm>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MatchArm>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchArm is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Pat {
    pub id: trap::TrapId<Pat>,
}

impl trap::TrapEntry for Pat {
    fn class_name() -> &'static str { "Pat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("pats", vec![id.into()]);
    }
}

impl From<trap::Label<Pat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Pat>) -> Self {
        // SAFETY: this is safe because in the dbscheme Pat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Pat>> for trap::Label<Element> {
    fn from(value: trap::Label<Pat>) -> Self {
        // SAFETY: this is safe because in the dbscheme Pat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Pat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Pat>) -> Self {
        // SAFETY: this is safe because in the dbscheme Pat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RecordFieldPat {
    pub id: trap::TrapId<RecordFieldPat>,
    pub name: String,
    pub pat: trap::Label<Pat>,
}

impl trap::TrapEntry for RecordFieldPat {
    fn class_name() -> &'static str { "RecordFieldPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("record_field_pats", vec![id.into(), self.name.into(), self.pat.into()]);
    }
}

impl From<trap::Label<RecordFieldPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RecordFieldPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordFieldPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordFieldPat>> for trap::Label<Element> {
    fn from(value: trap::Label<RecordFieldPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordFieldPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordFieldPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RecordFieldPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordFieldPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RecordLitField {
    pub id: trap::TrapId<RecordLitField>,
    pub name: String,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for RecordLitField {
    fn class_name() -> &'static str { "RecordLitField" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("record_lit_fields", vec![id.into(), self.name.into(), self.expr.into()]);
    }
}

impl From<trap::Label<RecordLitField>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RecordLitField>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordLitField is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordLitField>> for trap::Label<Element> {
    fn from(value: trap::Label<RecordLitField>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordLitField is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordLitField>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RecordLitField>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordLitField is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Stmt {
    pub id: trap::TrapId<Stmt>,
}

impl trap::TrapEntry for Stmt {
    fn class_name() -> &'static str { "Stmt" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("stmts", vec![id.into()]);
    }
}

impl From<trap::Label<Stmt>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Stmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme Stmt is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Stmt>> for trap::Label<Element> {
    fn from(value: trap::Label<Stmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme Stmt is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Stmt>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Stmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme Stmt is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct TypeRef {
    pub id: trap::TrapId<TypeRef>,
}

impl trap::TrapEntry for TypeRef {
    fn class_name() -> &'static str { "TypeRef" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("type_refs", vec![id.into()]);
    }
}

impl From<trap::Label<TypeRef>> for trap::Label<AstNode> {
    fn from(value: trap::Label<TypeRef>) -> Self {
        // SAFETY: this is safe because in the dbscheme TypeRef is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TypeRef>> for trap::Label<Element> {
    fn from(value: trap::Label<TypeRef>) -> Self {
        // SAFETY: this is safe because in the dbscheme TypeRef is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TypeRef>> for trap::Label<Locatable> {
    fn from(value: trap::Label<TypeRef>) -> Self {
        // SAFETY: this is safe because in the dbscheme TypeRef is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ArrayExpr {
    pub id: trap::TrapId<ArrayExpr>,
}

impl trap::TrapEntry for ArrayExpr {
    fn class_name() -> &'static str { "ArrayExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("array_exprs", vec![id.into()]);
    }
}

impl From<trap::Label<ArrayExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ArrayExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ArrayExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ArrayExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ArrayExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ArrayExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ArrayExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ArrayExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ArrayExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ArrayExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ArrayExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ArrayExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct AwaitExpr {
    pub id: trap::TrapId<AwaitExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for AwaitExpr {
    fn class_name() -> &'static str { "AwaitExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("await_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl From<trap::Label<AwaitExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<AwaitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AwaitExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AwaitExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<AwaitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AwaitExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AwaitExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<AwaitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AwaitExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AwaitExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<AwaitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AwaitExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BecomeExpr {
    pub id: trap::TrapId<BecomeExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for BecomeExpr {
    fn class_name() -> &'static str { "BecomeExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("become_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl From<trap::Label<BecomeExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BecomeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BecomeExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BecomeExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BecomeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BecomeExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BecomeExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BecomeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BecomeExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BecomeExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BecomeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BecomeExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BinaryOpExpr {
    pub id: trap::TrapId<BinaryOpExpr>,
    pub lhs: trap::Label<Expr>,
    pub rhs: trap::Label<Expr>,
    pub op: Option<String>,
}

impl trap::TrapEntry for BinaryOpExpr {
    fn class_name() -> &'static str { "BinaryOpExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("binary_op_exprs", vec![id.into(), self.lhs.into(), self.rhs.into()]);
        if let Some(v) = self.op {
            out.add_tuple("binary_op_expr_ops", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<BinaryOpExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BinaryOpExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BinaryOpExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BinaryOpExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BinaryOpExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BinaryOpExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BinaryOpExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BinaryOpExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BinaryOpExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BinaryOpExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BinaryOpExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BinaryOpExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BindPat {
    pub id: trap::TrapId<BindPat>,
    pub binding_id: String,
    pub subpat: Option<trap::Label<Pat>>,
}

impl trap::TrapEntry for BindPat {
    fn class_name() -> &'static str { "BindPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("bind_pats", vec![id.into(), self.binding_id.into()]);
        if let Some(v) = self.subpat {
            out.add_tuple("bind_pat_subpats", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<BindPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BindPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BindPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BindPat>> for trap::Label<Element> {
    fn from(value: trap::Label<BindPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BindPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BindPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BindPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BindPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BindPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<BindPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BindPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BlockExprBase {
    pub id: trap::TrapId<BlockExprBase>,
}

impl trap::TrapEntry for BlockExprBase {
    fn class_name() -> &'static str { "BlockExprBase" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("block_expr_bases", vec![id.into()]);
    }
}

impl From<trap::Label<BlockExprBase>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BlockExprBase>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExprBase is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExprBase>> for trap::Label<Element> {
    fn from(value: trap::Label<BlockExprBase>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExprBase is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExprBase>> for trap::Label<Expr> {
    fn from(value: trap::Label<BlockExprBase>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExprBase is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExprBase>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BlockExprBase>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExprBase is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BoxExpr {
    pub id: trap::TrapId<BoxExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for BoxExpr {
    fn class_name() -> &'static str { "BoxExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("box_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl From<trap::Label<BoxExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BoxExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BoxExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BoxExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BoxExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BoxPat {
    pub id: trap::TrapId<BoxPat>,
    pub inner: trap::Label<Pat>,
}

impl trap::TrapEntry for BoxPat {
    fn class_name() -> &'static str { "BoxPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("box_pats", vec![id.into(), self.inner.into()]);
    }
}

impl From<trap::Label<BoxPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BoxPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxPat>> for trap::Label<Element> {
    fn from(value: trap::Label<BoxPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BoxPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<BoxPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BreakExpr {
    pub id: trap::TrapId<BreakExpr>,
    pub expr: Option<trap::Label<Expr>>,
    pub label: Option<trap::Label<Label>>,
}

impl trap::TrapEntry for BreakExpr {
    fn class_name() -> &'static str { "BreakExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("break_exprs", vec![id.into()]);
        if let Some(v) = self.expr {
            out.add_tuple("break_expr_exprs", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.label {
            out.add_tuple("break_expr_labels", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<BreakExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BreakExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BreakExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BreakExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BreakExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BreakExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BreakExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BreakExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BreakExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BreakExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BreakExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BreakExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct CallExpr {
    pub id: trap::TrapId<CallExpr>,
    pub callee: trap::Label<Expr>,
    pub args: Vec<trap::Label<Expr>>,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for CallExpr {
    fn class_name() -> &'static str { "CallExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("call_exprs", vec![id.into(), self.callee.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("call_expr_args", vec![id.into(), i.into(), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("call_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl From<trap::Label<CallExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<CallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CallExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CallExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<CallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CallExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CallExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<CallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CallExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CallExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<CallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CallExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct CastExpr {
    pub id: trap::TrapId<CastExpr>,
    pub expr: trap::Label<Expr>,
    pub type_ref: trap::Label<TypeRef>,
}

impl trap::TrapEntry for CastExpr {
    fn class_name() -> &'static str { "CastExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("cast_exprs", vec![id.into(), self.expr.into(), self.type_ref.into()]);
    }
}

impl From<trap::Label<CastExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<CastExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CastExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CastExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<CastExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CastExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CastExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<CastExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CastExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CastExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<CastExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CastExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ClosureExpr {
    pub id: trap::TrapId<ClosureExpr>,
    pub args: Vec<trap::Label<Pat>>,
    pub arg_types: Vec<Option<trap::Label<TypeRef>>>,
    pub ret_type: Option<trap::Label<TypeRef>>,
    pub body: trap::Label<Expr>,
    pub closure_kind: String,
    pub is_move: bool,
}

impl trap::TrapEntry for ClosureExpr {
    fn class_name() -> &'static str { "ClosureExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("closure_exprs", vec![id.into(), self.body.into(), self.closure_kind.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("closure_expr_args", vec![id.into(), i.into(), v.into()]);
        }
        for (i, v) in self.arg_types.into_iter().enumerate() {
            if let Some(v) = v {
                out.add_tuple("closure_expr_arg_types", vec![id.into(), i.into(), v.into()]);
            }
        }
        if let Some(v) = self.ret_type {
            out.add_tuple("closure_expr_ret_types", vec![id.into(), v.into()]);
        }
        if self.is_move {
            out.add_tuple("closure_expr_is_move", vec![id.into()]);
        }
    }
}

impl From<trap::Label<ClosureExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ClosureExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ClosureExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ClosureExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ClosureExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ClosureExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ClosureExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ClosureExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ClosureExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ClosureExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ClosureExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ClosureExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ConstBlockPat {
    pub id: trap::TrapId<ConstBlockPat>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for ConstBlockPat {
    fn class_name() -> &'static str { "ConstBlockPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("const_block_pats", vec![id.into(), self.expr.into()]);
    }
}

impl From<trap::Label<ConstBlockPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ConstBlockPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstBlockPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstBlockPat>> for trap::Label<Element> {
    fn from(value: trap::Label<ConstBlockPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstBlockPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstBlockPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ConstBlockPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstBlockPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstBlockPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<ConstBlockPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstBlockPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ConstExpr {
    pub id: trap::TrapId<ConstExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for ConstExpr {
    fn class_name() -> &'static str { "ConstExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("const_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl From<trap::Label<ConstExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ConstExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ConstExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ConstExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ConstExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ContinueExpr {
    pub id: trap::TrapId<ContinueExpr>,
    pub label: Option<trap::Label<Label>>,
}

impl trap::TrapEntry for ContinueExpr {
    fn class_name() -> &'static str { "ContinueExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("continue_exprs", vec![id.into()]);
        if let Some(v) = self.label {
            out.add_tuple("continue_expr_labels", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<ContinueExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ContinueExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ContinueExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ContinueExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ContinueExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ContinueExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ContinueExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ContinueExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ContinueExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ContinueExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ContinueExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ContinueExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ExprStmt {
    pub id: trap::TrapId<ExprStmt>,
    pub expr: trap::Label<Expr>,
    pub has_semicolon: bool,
}

impl trap::TrapEntry for ExprStmt {
    fn class_name() -> &'static str { "ExprStmt" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("expr_stmts", vec![id.into(), self.expr.into()]);
        if self.has_semicolon {
            out.add_tuple("expr_stmt_has_semicolon", vec![id.into()]);
        }
    }
}

impl From<trap::Label<ExprStmt>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ExprStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ExprStmt is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ExprStmt>> for trap::Label<Element> {
    fn from(value: trap::Label<ExprStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ExprStmt is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ExprStmt>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ExprStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ExprStmt is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ExprStmt>> for trap::Label<Stmt> {
    fn from(value: trap::Label<ExprStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ExprStmt is a subclass of Stmt
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct FieldExpr {
    pub id: trap::TrapId<FieldExpr>,
    pub expr: trap::Label<Expr>,
    pub name: String,
}

impl trap::TrapEntry for FieldExpr {
    fn class_name() -> &'static str { "FieldExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("field_exprs", vec![id.into(), self.expr.into(), self.name.into()]);
    }
}

impl From<trap::Label<FieldExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<FieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme FieldExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<FieldExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<FieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme FieldExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<FieldExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<FieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme FieldExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<FieldExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<FieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme FieldExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Function {
    pub id: trap::TrapId<Function>,
    pub name: String,
    pub body: trap::Label<Expr>,
}

impl trap::TrapEntry for Function {
    fn class_name() -> &'static str { "Function" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("functions", vec![id.into(), self.name.into(), self.body.into()]);
    }
}

impl From<trap::Label<Function>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Function>) -> Self {
        // SAFETY: this is safe because in the dbscheme Function is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Function>> for trap::Label<Declaration> {
    fn from(value: trap::Label<Function>) -> Self {
        // SAFETY: this is safe because in the dbscheme Function is a subclass of Declaration
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Function>> for trap::Label<Element> {
    fn from(value: trap::Label<Function>) -> Self {
        // SAFETY: this is safe because in the dbscheme Function is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Function>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Function>) -> Self {
        // SAFETY: this is safe because in the dbscheme Function is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct IfExpr {
    pub id: trap::TrapId<IfExpr>,
    pub condition: trap::Label<Expr>,
    pub then: trap::Label<Expr>,
    pub else_: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for IfExpr {
    fn class_name() -> &'static str { "IfExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("if_exprs", vec![id.into(), self.condition.into(), self.then.into()]);
        if let Some(v) = self.else_ {
            out.add_tuple("if_expr_elses", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<IfExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<IfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IfExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IfExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<IfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IfExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IfExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<IfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IfExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IfExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<IfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IfExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct IndexExpr {
    pub id: trap::TrapId<IndexExpr>,
    pub base: trap::Label<Expr>,
    pub index: trap::Label<Expr>,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for IndexExpr {
    fn class_name() -> &'static str { "IndexExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("index_exprs", vec![id.into(), self.base.into(), self.index.into()]);
        if self.is_assignee_expr {
            out.add_tuple("index_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl From<trap::Label<IndexExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<IndexExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IndexExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IndexExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<IndexExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IndexExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IndexExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<IndexExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IndexExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IndexExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<IndexExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IndexExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct InlineAsmExpr {
    pub id: trap::TrapId<InlineAsmExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for InlineAsmExpr {
    fn class_name() -> &'static str { "InlineAsmExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("inline_asm_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl From<trap::Label<InlineAsmExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<InlineAsmExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme InlineAsmExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<InlineAsmExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<InlineAsmExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme InlineAsmExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<InlineAsmExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<InlineAsmExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme InlineAsmExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<InlineAsmExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<InlineAsmExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme InlineAsmExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ItemStmt {
    pub id: trap::TrapId<ItemStmt>,
}

impl trap::TrapEntry for ItemStmt {
    fn class_name() -> &'static str { "ItemStmt" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("item_stmts", vec![id.into()]);
    }
}

impl From<trap::Label<ItemStmt>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ItemStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ItemStmt is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ItemStmt>> for trap::Label<Element> {
    fn from(value: trap::Label<ItemStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ItemStmt is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ItemStmt>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ItemStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ItemStmt is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ItemStmt>> for trap::Label<Stmt> {
    fn from(value: trap::Label<ItemStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ItemStmt is a subclass of Stmt
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LetExpr {
    pub id: trap::TrapId<LetExpr>,
    pub pat: trap::Label<Pat>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for LetExpr {
    fn class_name() -> &'static str { "LetExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("let_exprs", vec![id.into(), self.pat.into(), self.expr.into()]);
    }
}

impl From<trap::Label<LetExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<LetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<LetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LetStmt {
    pub id: trap::TrapId<LetStmt>,
    pub pat: trap::Label<Pat>,
    pub type_ref: Option<trap::Label<TypeRef>>,
    pub initializer: Option<trap::Label<Expr>>,
    pub else_: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for LetStmt {
    fn class_name() -> &'static str { "LetStmt" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("let_stmts", vec![id.into(), self.pat.into()]);
        if let Some(v) = self.type_ref {
            out.add_tuple("let_stmt_type_refs", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.initializer {
            out.add_tuple("let_stmt_initializers", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.else_ {
            out.add_tuple("let_stmt_elses", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<LetStmt>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LetStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetStmt is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetStmt>> for trap::Label<Element> {
    fn from(value: trap::Label<LetStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetStmt is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetStmt>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LetStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetStmt is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetStmt>> for trap::Label<Stmt> {
    fn from(value: trap::Label<LetStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetStmt is a subclass of Stmt
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LitPat {
    pub id: trap::TrapId<LitPat>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for LitPat {
    fn class_name() -> &'static str { "LitPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("lit_pats", vec![id.into(), self.expr.into()]);
    }
}

impl From<trap::Label<LitPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LitPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme LitPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LitPat>> for trap::Label<Element> {
    fn from(value: trap::Label<LitPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme LitPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LitPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LitPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme LitPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LitPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<LitPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme LitPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LiteralExpr {
    pub id: trap::TrapId<LiteralExpr>,
}

impl trap::TrapEntry for LiteralExpr {
    fn class_name() -> &'static str { "LiteralExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("literal_exprs", vec![id.into()]);
    }
}

impl From<trap::Label<LiteralExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LiteralExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LiteralExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<LiteralExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LiteralExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<LiteralExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LiteralExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LiteralExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LoopExpr {
    pub id: trap::TrapId<LoopExpr>,
    pub body: trap::Label<Expr>,
    pub label: Option<trap::Label<Label>>,
}

impl trap::TrapEntry for LoopExpr {
    fn class_name() -> &'static str { "LoopExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("loop_exprs", vec![id.into(), self.body.into()]);
        if let Some(v) = self.label {
            out.add_tuple("loop_expr_labels", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<LoopExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LoopExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LoopExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LoopExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<LoopExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LoopExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LoopExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<LoopExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LoopExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LoopExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LoopExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LoopExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MatchExpr {
    pub id: trap::TrapId<MatchExpr>,
    pub expr: trap::Label<Expr>,
    pub branches: Vec<trap::Label<MatchArm>>,
}

impl trap::TrapEntry for MatchExpr {
    fn class_name() -> &'static str { "MatchExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("match_exprs", vec![id.into(), self.expr.into()]);
        for (i, v) in self.branches.into_iter().enumerate() {
            out.add_tuple("match_expr_branches", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl From<trap::Label<MatchExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MatchExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<MatchExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<MatchExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MatchExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MethodCallExpr {
    pub id: trap::TrapId<MethodCallExpr>,
    pub receiver: trap::Label<Expr>,
    pub method_name: String,
    pub args: Vec<trap::Label<Expr>>,
    pub generic_args: Option<trap::Label<Unimplemented>>,
}

impl trap::TrapEntry for MethodCallExpr {
    fn class_name() -> &'static str { "MethodCallExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("method_call_exprs", vec![id.into(), self.receiver.into(), self.method_name.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("method_call_expr_args", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.generic_args {
            out.add_tuple("method_call_expr_generic_args", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<MethodCallExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MethodCallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MethodCallExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MethodCallExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<MethodCallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MethodCallExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MethodCallExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<MethodCallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MethodCallExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MethodCallExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MethodCallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MethodCallExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MissingExpr {
    pub id: trap::TrapId<MissingExpr>,
}

impl trap::TrapEntry for MissingExpr {
    fn class_name() -> &'static str { "MissingExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("missing_exprs", vec![id.into()]);
    }
}

impl From<trap::Label<MissingExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MissingPat {
    pub id: trap::TrapId<MissingPat>,
}

impl trap::TrapEntry for MissingPat {
    fn class_name() -> &'static str { "MissingPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("missing_pats", vec![id.into()]);
    }
}

impl From<trap::Label<MissingPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingPat>> for trap::Label<Element> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Module {
    pub id: trap::TrapId<Module>,
    pub declarations: Vec<trap::Label<Declaration>>,
}

impl trap::TrapEntry for Module {
    fn class_name() -> &'static str { "Module" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("modules", vec![id.into()]);
        for (i, v) in self.declarations.into_iter().enumerate() {
            out.add_tuple("module_declarations", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl From<trap::Label<Module>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Module>) -> Self {
        // SAFETY: this is safe because in the dbscheme Module is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Module>> for trap::Label<Declaration> {
    fn from(value: trap::Label<Module>) -> Self {
        // SAFETY: this is safe because in the dbscheme Module is a subclass of Declaration
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Module>> for trap::Label<Element> {
    fn from(value: trap::Label<Module>) -> Self {
        // SAFETY: this is safe because in the dbscheme Module is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Module>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Module>) -> Self {
        // SAFETY: this is safe because in the dbscheme Module is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct OffsetOfExpr {
    pub id: trap::TrapId<OffsetOfExpr>,
    pub container: trap::Label<TypeRef>,
    pub fields: Vec<String>,
}

impl trap::TrapEntry for OffsetOfExpr {
    fn class_name() -> &'static str { "OffsetOfExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("offset_of_exprs", vec![id.into(), self.container.into()]);
        for (i, v) in self.fields.into_iter().enumerate() {
            out.add_tuple("offset_of_expr_fields", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl From<trap::Label<OffsetOfExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<OffsetOfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme OffsetOfExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OffsetOfExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<OffsetOfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme OffsetOfExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OffsetOfExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<OffsetOfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme OffsetOfExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OffsetOfExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<OffsetOfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme OffsetOfExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct OrPat {
    pub id: trap::TrapId<OrPat>,
    pub args: Vec<trap::Label<Pat>>,
}

impl trap::TrapEntry for OrPat {
    fn class_name() -> &'static str { "OrPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("or_pats", vec![id.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("or_pat_args", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl From<trap::Label<OrPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<OrPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme OrPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OrPat>> for trap::Label<Element> {
    fn from(value: trap::Label<OrPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme OrPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OrPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<OrPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme OrPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OrPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<OrPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme OrPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct PathExpr {
    pub id: trap::TrapId<PathExpr>,
    pub path: trap::Label<Unimplemented>,
}

impl trap::TrapEntry for PathExpr {
    fn class_name() -> &'static str { "PathExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("path_exprs", vec![id.into(), self.path.into()]);
    }
}

impl From<trap::Label<PathExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<PathExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<PathExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<PathExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<PathExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct PathPat {
    pub id: trap::TrapId<PathPat>,
    pub path: trap::Label<Unimplemented>,
}

impl trap::TrapEntry for PathPat {
    fn class_name() -> &'static str { "PathPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("path_pats", vec![id.into(), self.path.into()]);
    }
}

impl From<trap::Label<PathPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<PathPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathPat>> for trap::Label<Element> {
    fn from(value: trap::Label<PathPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<PathPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<PathPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RangeExpr {
    pub id: trap::TrapId<RangeExpr>,
    pub lhs: Option<trap::Label<Expr>>,
    pub rhs: Option<trap::Label<Expr>>,
    pub is_inclusive: bool,
}

impl trap::TrapEntry for RangeExpr {
    fn class_name() -> &'static str { "RangeExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("range_exprs", vec![id.into()]);
        if let Some(v) = self.lhs {
            out.add_tuple("range_expr_lhs", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.rhs {
            out.add_tuple("range_expr_rhs", vec![id.into(), v.into()]);
        }
        if self.is_inclusive {
            out.add_tuple("range_expr_is_inclusive", vec![id.into()]);
        }
    }
}

impl From<trap::Label<RangeExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RangeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangeExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangeExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<RangeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangeExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangeExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<RangeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangeExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangeExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RangeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangeExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RangePat {
    pub id: trap::TrapId<RangePat>,
    pub start: Option<trap::Label<Pat>>,
    pub end: Option<trap::Label<Pat>>,
}

impl trap::TrapEntry for RangePat {
    fn class_name() -> &'static str { "RangePat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("range_pats", vec![id.into()]);
        if let Some(v) = self.start {
            out.add_tuple("range_pat_starts", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.end {
            out.add_tuple("range_pat_ends", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<RangePat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RangePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangePat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangePat>> for trap::Label<Element> {
    fn from(value: trap::Label<RangePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangePat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangePat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RangePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangePat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangePat>> for trap::Label<Pat> {
    fn from(value: trap::Label<RangePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangePat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RecordLitExpr {
    pub id: trap::TrapId<RecordLitExpr>,
    pub path: Option<trap::Label<Unimplemented>>,
    pub fields: Vec<trap::Label<RecordLitField>>,
    pub spread: Option<trap::Label<Expr>>,
    pub has_ellipsis: bool,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for RecordLitExpr {
    fn class_name() -> &'static str { "RecordLitExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("record_lit_exprs", vec![id.into()]);
        if let Some(v) = self.path {
            out.add_tuple("record_lit_expr_paths", vec![id.into(), v.into()]);
        }
        for (i, v) in self.fields.into_iter().enumerate() {
            out.add_tuple("record_lit_expr_fields", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.spread {
            out.add_tuple("record_lit_expr_spreads", vec![id.into(), v.into()]);
        }
        if self.has_ellipsis {
            out.add_tuple("record_lit_expr_has_ellipsis", vec![id.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("record_lit_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl From<trap::Label<RecordLitExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RecordLitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordLitExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordLitExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<RecordLitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordLitExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordLitExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<RecordLitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordLitExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordLitExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RecordLitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordLitExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RecordPat {
    pub id: trap::TrapId<RecordPat>,
    pub path: Option<trap::Label<Unimplemented>>,
    pub args: Vec<trap::Label<RecordFieldPat>>,
    pub has_ellipsis: bool,
}

impl trap::TrapEntry for RecordPat {
    fn class_name() -> &'static str { "RecordPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("record_pats", vec![id.into()]);
        if let Some(v) = self.path {
            out.add_tuple("record_pat_paths", vec![id.into(), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("record_pat_args", vec![id.into(), i.into(), v.into()]);
        }
        if self.has_ellipsis {
            out.add_tuple("record_pat_has_ellipsis", vec![id.into()]);
        }
    }
}

impl From<trap::Label<RecordPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RecordPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordPat>> for trap::Label<Element> {
    fn from(value: trap::Label<RecordPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RecordPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<RecordPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RefExpr {
    pub id: trap::TrapId<RefExpr>,
    pub expr: trap::Label<Expr>,
    pub is_raw: bool,
    pub is_mut: bool,
}

impl trap::TrapEntry for RefExpr {
    fn class_name() -> &'static str { "RefExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("ref_exprs", vec![id.into(), self.expr.into()]);
        if self.is_raw {
            out.add_tuple("ref_expr_is_raw", vec![id.into()]);
        }
        if self.is_mut {
            out.add_tuple("ref_expr_is_mut", vec![id.into()]);
        }
    }
}

impl From<trap::Label<RefExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RefExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<RefExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<RefExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RefExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RefPat {
    pub id: trap::TrapId<RefPat>,
    pub pat: trap::Label<Pat>,
    pub is_mut: bool,
}

impl trap::TrapEntry for RefPat {
    fn class_name() -> &'static str { "RefPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("ref_pats", vec![id.into(), self.pat.into()]);
        if self.is_mut {
            out.add_tuple("ref_pat_is_mut", vec![id.into()]);
        }
    }
}

impl From<trap::Label<RefPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RefPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefPat>> for trap::Label<Element> {
    fn from(value: trap::Label<RefPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RefPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<RefPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ReturnExpr {
    pub id: trap::TrapId<ReturnExpr>,
    pub expr: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for ReturnExpr {
    fn class_name() -> &'static str { "ReturnExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("return_exprs", vec![id.into()]);
        if let Some(v) = self.expr {
            out.add_tuple("return_expr_exprs", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<ReturnExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ReturnExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ReturnExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ReturnExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ReturnExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ReturnExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ReturnExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ReturnExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ReturnExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ReturnExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ReturnExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ReturnExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct SlicePat {
    pub id: trap::TrapId<SlicePat>,
    pub prefix: Vec<trap::Label<Pat>>,
    pub slice: Option<trap::Label<Pat>>,
    pub suffix: Vec<trap::Label<Pat>>,
}

impl trap::TrapEntry for SlicePat {
    fn class_name() -> &'static str { "SlicePat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("slice_pats", vec![id.into()]);
        for (i, v) in self.prefix.into_iter().enumerate() {
            out.add_tuple("slice_pat_prefixes", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.slice {
            out.add_tuple("slice_pat_slice", vec![id.into(), v.into()]);
        }
        for (i, v) in self.suffix.into_iter().enumerate() {
            out.add_tuple("slice_pat_suffixes", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl From<trap::Label<SlicePat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<SlicePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme SlicePat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<SlicePat>> for trap::Label<Element> {
    fn from(value: trap::Label<SlicePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme SlicePat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<SlicePat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<SlicePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme SlicePat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<SlicePat>> for trap::Label<Pat> {
    fn from(value: trap::Label<SlicePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme SlicePat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct TupleExpr {
    pub id: trap::TrapId<TupleExpr>,
    pub exprs: Vec<trap::Label<Expr>>,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for TupleExpr {
    fn class_name() -> &'static str { "TupleExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("tuple_exprs", vec![id.into()]);
        for (i, v) in self.exprs.into_iter().enumerate() {
            out.add_tuple("tuple_expr_exprs", vec![id.into(), i.into(), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("tuple_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl From<trap::Label<TupleExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<TupleExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<TupleExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<TupleExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<TupleExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct TuplePat {
    pub id: trap::TrapId<TuplePat>,
    pub args: Vec<trap::Label<Pat>>,
    pub ellipsis_index: Option<usize>,
}

impl trap::TrapEntry for TuplePat {
    fn class_name() -> &'static str { "TuplePat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("tuple_pats", vec![id.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("tuple_pat_args", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.ellipsis_index {
            out.add_tuple("tuple_pat_ellipsis_indices", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<TuplePat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<TuplePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TuplePat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TuplePat>> for trap::Label<Element> {
    fn from(value: trap::Label<TuplePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TuplePat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TuplePat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<TuplePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TuplePat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TuplePat>> for trap::Label<Pat> {
    fn from(value: trap::Label<TuplePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TuplePat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct TupleStructPat {
    pub id: trap::TrapId<TupleStructPat>,
    pub path: Option<trap::Label<Unimplemented>>,
    pub args: Vec<trap::Label<Pat>>,
    pub ellipsis_index: Option<usize>,
}

impl trap::TrapEntry for TupleStructPat {
    fn class_name() -> &'static str { "TupleStructPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("tuple_struct_pats", vec![id.into()]);
        if let Some(v) = self.path {
            out.add_tuple("tuple_struct_pat_paths", vec![id.into(), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("tuple_struct_pat_args", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.ellipsis_index {
            out.add_tuple("tuple_struct_pat_ellipsis_indices", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<TupleStructPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<TupleStructPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleStructPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleStructPat>> for trap::Label<Element> {
    fn from(value: trap::Label<TupleStructPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleStructPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleStructPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<TupleStructPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleStructPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleStructPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<TupleStructPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleStructPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct UnaryOpExpr {
    pub id: trap::TrapId<UnaryOpExpr>,
    pub expr: trap::Label<Expr>,
    pub op: String,
}

impl trap::TrapEntry for UnaryOpExpr {
    fn class_name() -> &'static str { "UnaryOpExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("unary_op_exprs", vec![id.into(), self.expr.into(), self.op.into()]);
    }
}

impl From<trap::Label<UnaryOpExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<UnaryOpExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnaryOpExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnaryOpExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<UnaryOpExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnaryOpExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnaryOpExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<UnaryOpExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnaryOpExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnaryOpExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<UnaryOpExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnaryOpExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct UnderscoreExpr {
    pub id: trap::TrapId<UnderscoreExpr>,
}

impl trap::TrapEntry for UnderscoreExpr {
    fn class_name() -> &'static str { "UnderscoreExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("underscore_exprs", vec![id.into()]);
    }
}

impl From<trap::Label<UnderscoreExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<UnderscoreExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnderscoreExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnderscoreExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<UnderscoreExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnderscoreExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnderscoreExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<UnderscoreExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnderscoreExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnderscoreExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<UnderscoreExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnderscoreExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Unimplemented {
    pub id: trap::TrapId<Unimplemented>,
}

impl trap::TrapEntry for Unimplemented {
    fn class_name() -> &'static str { "Unimplemented" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("unimplementeds", vec![id.into()]);
    }
}

impl From<trap::Label<Unimplemented>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Unimplemented>) -> Self {
        // SAFETY: this is safe because in the dbscheme Unimplemented is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Unimplemented>> for trap::Label<Declaration> {
    fn from(value: trap::Label<Unimplemented>) -> Self {
        // SAFETY: this is safe because in the dbscheme Unimplemented is a subclass of Declaration
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Unimplemented>> for trap::Label<Element> {
    fn from(value: trap::Label<Unimplemented>) -> Self {
        // SAFETY: this is safe because in the dbscheme Unimplemented is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Unimplemented>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Unimplemented>) -> Self {
        // SAFETY: this is safe because in the dbscheme Unimplemented is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Unimplemented>> for trap::Label<TypeRef> {
    fn from(value: trap::Label<Unimplemented>) -> Self {
        // SAFETY: this is safe because in the dbscheme Unimplemented is a subclass of TypeRef
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct WildPat {
    pub id: trap::TrapId<WildPat>,
}

impl trap::TrapEntry for WildPat {
    fn class_name() -> &'static str { "WildPat" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("wild_pats", vec![id.into()]);
    }
}

impl From<trap::Label<WildPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<WildPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme WildPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<WildPat>> for trap::Label<Element> {
    fn from(value: trap::Label<WildPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme WildPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<WildPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<WildPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme WildPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<WildPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<WildPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme WildPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct YeetExpr {
    pub id: trap::TrapId<YeetExpr>,
    pub expr: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for YeetExpr {
    fn class_name() -> &'static str { "YeetExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("yeet_exprs", vec![id.into()]);
        if let Some(v) = self.expr {
            out.add_tuple("yeet_expr_exprs", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<YeetExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<YeetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YeetExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YeetExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<YeetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YeetExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YeetExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<YeetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YeetExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YeetExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<YeetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YeetExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct YieldExpr {
    pub id: trap::TrapId<YieldExpr>,
    pub expr: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for YieldExpr {
    fn class_name() -> &'static str { "YieldExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("yield_exprs", vec![id.into()]);
        if let Some(v) = self.expr {
            out.add_tuple("yield_expr_exprs", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<YieldExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<YieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YieldExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YieldExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<YieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YieldExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YieldExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<YieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YieldExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YieldExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<YieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YieldExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct AsyncBlockExpr {
    pub id: trap::TrapId<AsyncBlockExpr>,
    pub statements: Vec<trap::Label<Stmt>>,
    pub tail: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for AsyncBlockExpr {
    fn class_name() -> &'static str { "AsyncBlockExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("async_block_exprs", vec![id.into()]);
        for (i, v) in self.statements.into_iter().enumerate() {
            out.add_tuple("block_expr_base_statements", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.tail {
            out.add_tuple("block_expr_base_tails", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<BlockExprBase> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of BlockExprBase
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BlockExpr {
    pub id: trap::TrapId<BlockExpr>,
    pub statements: Vec<trap::Label<Stmt>>,
    pub tail: Option<trap::Label<Expr>>,
    pub label: Option<trap::Label<Label>>,
}

impl trap::TrapEntry for BlockExpr {
    fn class_name() -> &'static str { "BlockExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("block_exprs", vec![id.into()]);
        for (i, v) in self.statements.into_iter().enumerate() {
            out.add_tuple("block_expr_base_statements", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.tail {
            out.add_tuple("block_expr_base_tails", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.label {
            out.add_tuple("block_expr_labels", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<BlockExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExpr>> for trap::Label<BlockExprBase> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of BlockExprBase
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ElementListExpr {
    pub id: trap::TrapId<ElementListExpr>,
    pub elements: Vec<trap::Label<Expr>>,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for ElementListExpr {
    fn class_name() -> &'static str { "ElementListExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("element_list_exprs", vec![id.into()]);
        for (i, v) in self.elements.into_iter().enumerate() {
            out.add_tuple("element_list_expr_elements", vec![id.into(), i.into(), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("element_list_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<ArrayExpr> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of ArrayExpr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RepeatExpr {
    pub id: trap::TrapId<RepeatExpr>,
    pub initializer: trap::Label<Expr>,
    pub repeat: trap::Label<Expr>,
}

impl trap::TrapEntry for RepeatExpr {
    fn class_name() -> &'static str { "RepeatExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("repeat_exprs", vec![id.into(), self.initializer.into(), self.repeat.into()]);
    }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<ArrayExpr> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of ArrayExpr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct UnsafeBlockExpr {
    pub id: trap::TrapId<UnsafeBlockExpr>,
    pub statements: Vec<trap::Label<Stmt>>,
    pub tail: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for UnsafeBlockExpr {
    fn class_name() -> &'static str { "UnsafeBlockExpr" }

    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("unsafe_block_exprs", vec![id.into()]);
        for (i, v) in self.statements.into_iter().enumerate() {
            out.add_tuple("block_expr_base_statements", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.tail {
            out.add_tuple("block_expr_base_tails", vec![id.into(), v.into()]);
        }
    }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<BlockExprBase> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of BlockExprBase
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}
