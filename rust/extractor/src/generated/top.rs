// generated by codegen

use crate::trap::{TrapLabel, TrapId, TrapEntry, quoted};
use std::io::Write;

#[derive(Debug)]
pub struct DbFile {
    pub id: TrapId,
    pub name: String,
}

impl TrapEntry for DbFile {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit<W: Write>(self, id: TrapLabel, out: &mut W) -> std::io::Result<()> {
        write!(out, "db_files({id})\n")?;
        write!(out, "files({id}, {})\n", quoted(&self.name))?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct DbLocation {
    pub id: TrapId,
    pub file: TrapLabel,
    pub start_line: u32,
    pub start_column: u32,
    pub end_line: u32,
    pub end_column: u32,
}

impl TrapEntry for DbLocation {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit<W: Write>(self, id: TrapLabel, out: &mut W) -> std::io::Result<()> {
        write!(out, "db_locations({id})\n")?;
        write!(out, "locations({id}, {}, {}, {}, {}, {})\n", self.file, self.start_line, self.start_column, self.end_line, self.end_column)?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct Function {
    pub id: TrapId,
    pub location: Option<TrapLabel>,
    pub name: String,
}

impl TrapEntry for Function {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit<W: Write>(self, id: TrapLabel, out: &mut W) -> std::io::Result<()> {
        write!(out, "functions({id}, {})\n", quoted(&self.name))?;
        if let Some(ref v) = &self.location {
            write!(out, "locatable_locations({id}, {})\n", v)?;
        }
        Ok(())
    }
}

#[derive(Debug)]
pub struct Module {
    pub id: TrapId,
    pub location: Option<TrapLabel>,
    pub declarations: Vec<TrapLabel>,
}

impl TrapEntry for Module {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit<W: Write>(self, id: TrapLabel, out: &mut W) -> std::io::Result<()> {
        write!(out, "modules({id})\n")?;
        if let Some(ref v) = &self.location {
            write!(out, "locatable_locations({id}, {})\n", v)?;
        }
        for (i, &ref v) in self.declarations.iter().enumerate() {
            write!(out, "module_declarations({id}, {}, {})\n", i, v)?;
        }
        Ok(())
    }
}
